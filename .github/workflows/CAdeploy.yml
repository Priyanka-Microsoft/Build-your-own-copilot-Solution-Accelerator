name: CA Deploy-Test-Cleanup Pipeline


on:
  push:
    branches: [main, dev, demo]
  pull_request:
    branches: [main, dev, demo]
    types:
      - opened
      - ready_for_review
      - reopened
      - synchronize
  merge_group:
  workflow_dispatch:
  

env:
  GPT_MIN_CAPACITY: 250
  TEXT_EMBEDDING_MIN_CAPACITY: 40
  BRANCH_NAME: ${{ github.head_ref || github.ref_name }}

jobs:
  deploy:
    runs-on: ubuntu-22.04
    outputs:
      RESOURCE_GROUP_NAME: ${{ steps.check_create_rg.outputs.RESOURCE_GROUP_NAME }}
      WEBAPP_URL: ${{ steps.get_output.outputs.WEBAPP_URL }}
      DEPLOYMENT_SUCCESS: ${{ steps.deployment_status.outputs.SUCCESS }}
      AI_SERVICES_NAME: ${{ steps.get_ai_services_name.outputs.AI_SERVICES_NAME }}
      KEYVAULTS: ${{ steps.list_keyvaults.outputs.KEYVAULTS }}
      AZURE_LOCATION: ${{ steps.set_region.outputs.AZURE_LOCATION }}
      SOLUTION_PREFIX: ${{ steps.generate_solution_prefix.outputs.SOLUTION_PREFIX }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Install ODBC Driver 18 for SQL Server
        run: |
          curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
          sudo add-apt-repository "$(curl https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/prod.list)"
          sudo apt-get update
          sudo ACCEPT_EULA=Y apt-get install -y msodbcsql18
          sudo apt-get install -y unixodbc-dev

      - name: Setup Azure CLI
        run: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

      - name: Login to Azure
        run: |
          az login --service-principal -u ${{ secrets.AZURE_CLIENT_ID }} -p ${{ secrets.AZURE_CLIENT_SECRET }} --tenant ${{ secrets.AZURE_TENANT_ID }}
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Run Quota Check
        id: quota-check
        run: |
          export AZURE_CLIENT_ID="${{ secrets.AZURE_CLIENT_ID }}"
          export AZURE_TENANT_ID="${{ secrets.AZURE_TENANT_ID }}"
          export AZURE_CLIENT_SECRET="${{ secrets.AZURE_CLIENT_SECRET }}"
          export AZURE_SUBSCRIPTION_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          export GPT_MIN_CAPACITY="150"
          export TEXT_EMBEDDING_MIN_CAPACITY="80"
          export AZURE_REGIONS="${{ vars.AZURE_REGIONS_CA }}"
          chmod +x infra/scripts/checkquota.sh
          if ! infra/scripts/checkquota.sh; then
            if grep -q "No region with sufficient quota found" infra/scripts/checkquota_ca.sh; then
              echo "QUOTA_FAILED=true" >> $GITHUB_ENV
            fi
            exit 1
          fi

      - name: Notify on Quota Failure
        if: env.QUOTA_FAILED == 'true'
        run: |
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          curl -X POST "${{ secrets.LOGIC_APP_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "subject": "CA Deployment - Quota Check Failed",
              "body": "<p>The quota check failed for CA deployment.</p><p><a href=\"'${RUN_URL}'\">View run</a></p>"
            }'

      - name: Fail on Quota Check
        if: env.QUOTA_FAILED == 'true'
        run: exit 1

      - name: Install Bicep CLI
        run: az bicep install
        
      - name: Set Deployment Region
        id: set_region
        run: |
          echo "Selected Region: $VALID_REGION"
          echo "AZURE_LOCATION=$VALID_REGION" >> $GITHUB_ENV
          echo "AZURE_LOCATION=$VALID_REGION" >> $GITHUB_OUTPUT

      - name: Generate Resource Group Name
        id: generate_rg_name
        run: |
          echo "Generating a unique resource group name..."
          ACCL_NAME="ca"  # Account name as specified
          SHORT_UUID=$(uuidgen | cut -d'-' -f1)
          UNIQUE_RG_NAME="arg-${ACCL_NAME}-${SHORT_UUID}"
          echo "RESOURCE_GROUP_NAME=${UNIQUE_RG_NAME}" >> $GITHUB_ENV
          echo "Generated RESOURCE_GROUP_NAME: ${UNIQUE_RG_NAME}"
      
      - name: Check and Create Resource Group
        id: check_create_rg
        run: |
          echo "RESOURCE_GROUP: ${{ env.RESOURCE_GROUP_NAME }}"
          set -e  
          echo "Checking if resource group exists..."
          rg_exists=$(az group exists --name ${{ env.RESOURCE_GROUP_NAME }})
          if [ "$rg_exists" = "false" ]; then
            echo "Resource group does not exist. Creating..."
            az group create --name ${{ env.RESOURCE_GROUP_NAME }} --location ${{ env.AZURE_LOCATION }} || { echo "Error creating resource group"; exit 1; }
          else
            echo "Resource group already exists."
          fi
          # Set output for other jobs
          echo "RESOURCE_GROUP_NAME=${{ env.RESOURCE_GROUP_NAME }}" >> $GITHUB_OUTPUT
      
      - name: Generate Unique Solution Prefix
        id: generate_solution_prefix
        run: |
          set -e
          COMMON_PART="pslc"
          TIMESTAMP=$(date +%s)  
          UPDATED_TIMESTAMP=$(echo $TIMESTAMP | tail -c 3) 
          UNIQUE_SOLUTION_PREFIX="${COMMON_PART}${UPDATED_TIMESTAMP}"
          echo "SOLUTION_PREFIX=${UNIQUE_SOLUTION_PREFIX}" >> $GITHUB_ENV
          echo "SOLUTION_PREFIX=${UNIQUE_SOLUTION_PREFIX}" >> $GITHUB_OUTPUT
          echo "Generated SOLUTION_PREFIX: ${UNIQUE_SOLUTION_PREFIX}"

      - name: Determine Tag
        id: determine_tag
        run: |
          BRANCH=${{ github.ref_name }}
          if [[ "$BRANCH" == "main" ]]; then TAG="latest"
          elif [[ "$BRANCH" == "dev" ]]; then TAG="dev"
          elif [[ "$BRANCH" == "demo" ]]; then TAG="demo"
          else TAG="default"; fi
          echo "tagname=$TAG" >> $GITHUB_OUTPUT
      
      - name: Get Deployment Output and extract Values
        id: get_output
        run: |
          set -e
          echo "Fetching deployment output..."
          # Install azd (Azure Developer CLI) - required by process_sample_data.sh
          curl -fsSL https://aka.ms/install-azd.sh | bash

          DEPLOY_OUTPUT=$(az deployment group create \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --template-file infra/main.bicep \
            --parameters AzureOpenAILocation=${{ env.AZURE_LOCATION }} environmentName=${{ env.SOLUTION_PREFIX }} cosmosLocation=westus gptDeploymentCapacity=${{ env.GPT_MIN_CAPACITY }} embeddingDeploymentCapacity=${{ env.TEXT_EMBEDDING_MIN_CAPACITY }} \
            --query "properties.outputs" -o json)

          echo "Deployment output: $DEPLOY_OUTPUT"
          if [[ -z "$DEPLOY_OUTPUT" ]]; then
            echo "Error: Deployment output is empty. Please check the deployment logs."
            exit 1
          fi

          export COSMOS_DB_ACCOUNT_NAME=$(echo "$DEPLOY_OUTPUT" | jq -r '.cosmosdB_ACCOUNT_NAME.value')
          echo "COSMOS_DB_ACCOUNT_NAME=$COSMOS_DB_ACCOUNT_NAME" >> $GITHUB_ENV
          export STORAGE_ACCOUNT=$(echo "$DEPLOY_OUTPUT" | jq -r '.storagE_ACCOUNT_NAME.value')
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_ENV
          export STORAGE_CONTAINER=$(echo "$DEPLOY_OUTPUT" | jq -r '.storagE_CONTAINER_NAME.value')
          echo "STORAGE_CONTAINER=$STORAGE_CONTAINER" >> $GITHUB_ENV
          export KEYVAULT_NAME=$(echo "$DEPLOY_OUTPUT" | jq -r '.keY_VAULT_NAME.value')
          echo "KEYVAULT_NAME=$KEYVAULT_NAME" >> $GITHUB_ENV
          export SQL_SERVER=$(echo "$DEPLOY_OUTPUT" | jq -r '.sqldB_SERVER.value')
          echo "SQL_SERVER=$SQL_SERVER" >> $GITHUB_ENV
          export SQL_DATABASE=$(echo "$DEPLOY_OUTPUT" | jq -r '.sqldB_DATABASE.value')
          echo "SQL_DATABASE=$SQL_DATABASE" >> $GITHUB_ENV
          export CLIENT_ID=$(echo "$DEPLOY_OUTPUT" | jq -r '.managedindentitY_WEBAPP_CLIENTID.value')
          echo "CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
          export CLIENT_NAME=$(echo "$DEPLOY_OUTPUT" | jq -r '.managedindentitY_WEBAPP_NAME.value')
          echo "CLIENT_NAME=$CLIENT_NAME" >> $GITHUB_ENV
          export RG_NAME=$(echo "$DEPLOY_OUTPUT" | jq -r '.resourcE_GROUP_NAME.value')
          echo "RG_NAME=$RG_NAME" >> $GITHUB_ENV
          WEBAPP_URL=$(echo $DEPLOY_OUTPUT | jq -r '.weB_APP_URL.value')
          echo "WEBAPP_URL=$WEBAPP_URL" >> $GITHUB_OUTPUT
          echo "Deployment output: $DEPLOY_OUTPUT"

          export CLIENT_OBJECT_ID=$(az identity show \
                  --name "$CLIENT_NAME" \
                  --resource-group "$RG_NAME" \
                  --query 'principalId' -o tsv)
          echo "CLIENT_OBJECT_ID=$CLIENT_OBJECT_ID" >> $GITHUB_ENV

      - name: Deploy Infra and Import Sample Data 
        run: |
          set -e
          az account set --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"

          # Fixed Cosmos DB role assignment - using correct variable names
          az cosmosdb sql role assignment create \
            --account-name "${{ env.COSMOS_DB_ACCOUNT_NAME }}" \
            --resource-group "${{ env.RG_NAME }}" \
            --role-definition-name "Cosmos DB Built-in Data Contributor" \
            --scope "/" \
            --principal-id "${{ env.CLIENT_OBJECT_ID }}"

          echo "Running post-deployment script..."
          bash ./infra/scripts/add_cosmosdb_access.sh \
            "${{ env.RG_NAME }}" \
            "${{ env.COSMOS_DB_ACCOUNT_NAME }}" \
            "${{ secrets.AZURE_CLIENT_ID }}"
          bash ./infra/scripts/copy_kb_files.sh \
            "${{ env.STORAGE_ACCOUNT }}" \
            "${{ env.STORAGE_CONTAINER }}" \
            "" \
            "${{ secrets.AZURE_CLIENT_ID }}"
          bash ./infra/scripts/run_create_index_scripts.sh \
            "${{ env.KEYVAULT_NAME }}" \
            "" \
            "${{ secrets.AZURE_CLIENT_ID }}" \
            "${{ env.RG_NAME }}" \
            "${{ env.SQL_SERVER }}" \
          user_roles_json='[
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "displayName": "webapp-identity",
              "role": "db_datareader"
            },
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "displayName": "webapp-identity",
              "role": "db_datawriter"
            }
          ]'

          bash ./infra/scripts/add_user_scripts/create_sql_user_and_role.sh \
            "${{ env.SQL_SERVER }}.database.windows.net" \
            "${{ env.SQL_DATABASE }}" \
            "$user_roles_json"
          
          echo "=== Post-Deployment Script Completed Successfully ==="

      - name: Get AI Services name and store in variable
        if: always() && steps.check_create_rg.outcome == 'success'
        id: get_ai_services_name
        run: |
          set -e
          echo "Getting AI Services name..."
          # Get the AI Services name
          ai_services_name=$(az cognitiveservices account list -g ${{ env.RESOURCE_GROUP_NAME }} --query "[0].name" -o tsv)
          if [ -z "$ai_services_name" ]; then
            echo "No AI Services resource found in the resource group."
            echo "AI_SERVICES_NAME=" >> $GITHUB_OUTPUT
          else
            echo "AI_SERVICES_NAME=${ai_services_name}" >> $GITHUB_OUTPUT
            echo "Found AI Services resource: $ai_services_name"
          fi

      - name: List KeyVaults and Store in Array
        if: always() && steps.check_create_rg.outcome == 'success'
        id: list_keyvaults
        run: |
          set -e
          echo "Listing all KeyVaults in the resource group ${{ env.RESOURCE_GROUP_NAME }}..."
          
          # Get the list of KeyVaults in the specified resource group
          keyvaults=$(az resource list --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query "[?type=='Microsoft.KeyVault/vaults'].name" -o tsv)

          if [ -z "$keyvaults" ]; then
            echo "No KeyVaults found in resource group ${{ env.RESOURCE_GROUP_NAME }}."
            echo "KEYVAULTS=[]" >> $GITHUB_OUTPUT  # If no KeyVaults found, set an empty array
          else
            echo "KeyVaults found: $keyvaults"

            # Format the list into an array with proper formatting (no trailing comma)
            keyvault_array="["
            first=true
            for kv in $keyvaults; do
              if [ "$first" = true ]; then
                keyvault_array="$keyvault_array\"$kv\""
                first=false
              else
                keyvault_array="$keyvault_array,\"$kv\""
              fi
            done
            keyvault_array="$keyvault_array]"

            # Output the formatted array and save it to the job output
            echo "KEYVAULTS=$keyvault_array" >> $GITHUB_OUTPUT
          fi
          
      - name: Set Deployment Status
        id: deployment_status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "SUCCESS=true" >> $GITHUB_OUTPUT
          else
            echo "SUCCESS=false" >> $GITHUB_OUTPUT
          fi

      - name: Logout
        if: always()
        run: az logout

  e2e-test:
    needs: deploy
    if: needs.deploy.outputs.DEPLOYMENT_SUCCESS == 'true'
    uses: ./.github/workflows/test_automation.yml
    with:
      CA_WEB_URL: ${{ needs.deploy.outputs.WEBAPP_URL }}
    secrets: inherit